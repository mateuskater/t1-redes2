<h1 style="text-align: center;">Relatório - Trabalho 1 - Redes 2</h1>

<p>Iago Mello Floriano GRR20196049</p>
<p>Mateus Kater Pombeiro GRR20190366</p>

<h2>Introdução</h2>

<p>Este relatório tem como objetivo detalhar o que foi feito no trabalho 1 de Redes 2, bem como seu funcionamento, implementação e limitações.
O trabalho consiste de um servidor de streams, onde existe um host que transmite dados continuamente, e clientes podem conectar a esse host para receber os dados transmitidos, a qualquer momento.

Os dados em questão consistem na informação de teclas sendo pressionadas.

<h2>Implementação</h2>

O trabalho foi implementado usando Python, com a library de socket. O socket é iniciado utilizando o protocolo UDP, então é associado ao socket o IP do servidor.
Os clientes então utilizam o socket da mesma forma, para se conectar ao servidor pelo seu IP.

Quando um cliente inicia, ele envia uma mensagem de início para o IP fornecido por linha de comando, o do servidor. O servidor roda um laço principal, em que continuamente tenta receber uma mensagem do buffer local. Quando a mensagem é recebida com sucesso, o servidor adiciona o IP do remetente a uma lista de clientes, armazenada localmente. O servidor então itera essa lista de clientes, enviando suas mensagens para todos eles, a cada iteração do laço principal, por meio do método “sendto”.

A mensagem tem formato de tupla. O primeiro item da tupla é a ordem do pacote, e o segundo item é a mensagem enviada.

Antes de cada mensagem ser enviada, é necessário codificá-la para formato bytes. Para isto, é utilizada a library “pickle”, que tem o propósito de converter um objeto Python para um stream de bytes, assim possibilitando o envio e recebimento por socket.
<br>

<h1>Log de execução</h1>


<h1>Códigos fonte</h1>

<h2><a href="./server.py.txt">server.py</a></h2>
<pre>
<code class="Python">
    from pynput import keyboard
    from pynput.keyboard import Key, KeyCode
    import sys
    import socket
    import time
    import pickle

    BUFF = 65536
    CONNECTMSG = b'oi'
    keys = []

    def send(sock, clients, package):
        for addr in clients:
            try:
                sock.sendto(package,  addr)
            except Exception as e:
                #falhou em enviar msg
                pass

    def check_new_clients(sock, clients):
        while True:
            try:
                client_msg,addr = sock.recvfrom(BUFF)
                if client_msg == CONNECTMSG:
                    print('Novo cliente ouvindo: ',addr)
                    clients.append(addr)

                # if client_msg == b'cabou':
                # if client_msg == b'ack':
                # 	apacotes_recebidos+=1
            except:
                break

    def on_press(key):
        if keys.count(key) == 0:
            keys.append(key)
            if key == keyboard.Key.esc:
                print('para de apertar esc')
        # if key == keyboard.Key.esc:
        #     return False

    def on_release(key):
        while keys.count(key) > 0:
            keys.remove(key)

    def log(msg):
        print(msg)
        with open('log.txt', 'w') as file:
            file.write(msg)


    def checkArguments():
        if (len(sys.argv) != 3):
            print("Quantidade incorreta de argumentos, forma de uso correta:")
            print(sys.argv[0] + " <porta> <delay entre mensagens (segundos)>")
            quit()
        try:
            port = int(sys.argv[1])
        except Exception as e:
            print("Porta deve ser um inteiro, forma de uso correta:")
            print(sys.argv[0] + " <porta> <delay entre mensagens (segundos)>")
            quit()
        try:
            delay = float(sys.argv[2])
        except:
            print("Delay entre mensagens deve ser um número real, forma de uso correta:")
            print(sys.argv[0] + " <porta> <delay entre mensagens (segundos)>")
            quit()
        return (port, delay)

    def main(port, delay):
        print("Iniciando Servidor...")
        # Configures the socket
        sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
        sock.setsockopt(socket.SOL_SOCKET,socket.SO_RCVBUF,BUFF)
        timeout = min(delay, 0.2)
        sock.settimeout(timeout)
        delay = delay - timeout
        print("Socket iniciado!")
        host_name = socket.gethostname()
        host_ip = socket.gethostbyname(host_name)
        sock_addr = (host_ip,port)
        sock.bind(sock_addr)

        print("IP: ", host_ip)
        print('Porta: ',port)

        # setup keyboard listener
        listener = keyboard.Listener(on_press=on_press, on_release=on_release)
        listener.start()

        # main loop
        packCount = 1
        client_list = []
        while True:
            # sends next package in the sequence
            package = (packCount, keys)
            print(f"Enviando pacote: {package}")
            package = pickle.dumps(package)
            send(sock, client_list, package)
            packCount += 1
            # Encerra envio caso tenha enviado ctrl+c
            if keys.count(Key.ctrl) > 0 and keys.count(KeyCode.from_char('c')) > 0:
                break
            # adds new clients
            check_new_clients(sock, client_list)
            time.sleep(delay)
        listener.stop()
        print("Encerrando servidor")
        print(f"{packCount} pacotes foram enviados")
        print(f"{len(client_list)} clientes foram adicionados a lista de envios")

    if __name__ == '__main__':
        (port, delay) = checkArguments()
        main(port, delay)
    </code>
</pre>

<h2><a href="./client.py">client.py</a></h2>
<pre>
    <code>
        from pynput.keyboard import Controller, Key, KeyCode
        import sys
        import socket
        import pickle

        BUFF = 65536
        CONNECTMSG = b'oi'

        def receive(sock: socket.socket):
            pack = sock.recv(BUFF)
            return pack

        def checkArguments():
            if (len(sys.argv) != 3):
                print("Quantidade incorreta de argumentos, forma de uso correta:")
                print(sys.argv[0] + " <ip server> <porta server>")
                quit()
            try:
                server_port = int(sys.argv[2])
            except Exception as e:
                print("Porta deve ser um inteiro, forma de uso correta:")
                print(sys.argv[0] + " <ip server> <porta server>")
                quit()
            server_ip = sys.argv[1]

            return (server_ip, server_port)

        def log(msg):
            print(msg)
            with open('log.txt', 'w') as file:
                file.write(msg)

        def main(server_ip, server_port):
            print('Iniciando cliente...')
            # Configura o socket
            sock = socket.socket(socket.AF_INET,socket.SOCK_DGRAM)
            sock.setsockopt(socket.SOL_SOCKET,socket.SO_RCVBUF,BUFF)
            sock.settimeout(20)
            print("Socket iniciado!")
            print('IP: ',server_ip,server_port)

            print(f"Ouvindo {server_ip}, na porta {server_port}...")
            sock.sendto(CONNECTMSG ,(server_ip,server_port)) # envia msg de inicialização

            keyboard = Controller()
            oldKeys = []
            currPack = 0
            lostPacks = 0
            
            # recebe o primeiro pacote
            pack = receive(sock)
            packNum, newKeys = pickle.loads(pack)
            currPack = packNum
            firstPack = packNum
            print(f"Pacote {packNum} recebido.")
            try:
                while True:
                    # Para programa se foi apertado ctrl+c no servidor
                    if newKeys.count(Key.ctrl) > 0 and newKeys.count(KeyCode.from_char('c')) > 0:
                        # Solta teclas que ainda estão pressionadas
                        for key in newKeys:
                            keyboard.release(key)
                        break

                    for key in newKeys:
                        if oldKeys.count(key) == 0:
                            print(f"pressing {key}")
                            keyboard.press(key)
                    for key in oldKeys:
                        if newKeys.count(key) == 0:
                            print(f"releasing {key}")
                            keyboard.release(key)
                    oldKeys = newKeys
                    if len(newKeys) > 0:
                        print(newKeys[0])

                    pack = receive(sock)
                    packNum, newKeys = pickle.loads(pack)
                    lostPacks = lostPacks + (packNum - currPack - 1)
                    currPack = packNum
                    print(f"Pacote {packNum} recebido.")
            except TimeoutError:
                print("A Conexão foi encerrada após atingir 20 segundos de inatividade.")
                # print('Total de pacotes recebidos: ')
                print(f"Pacotes perdidos: {lostPacks}")
            except ConnectionResetError: 
                print('faiou')
            
            print("Servidor encerrou a transmissão")
            print(f"{currPack - firstPack - lostPacks} pacotes recebidos")
            print(f"{lostPacks} pacotes perdidos")
            print(f"Este cliente começou a receber a partir do pacote {firstPack}")
            print(f"Último pacote recebido por este cliente foi o de número {currPack}")

        if __name__ == '__main__':
            (server_ip, server_port) = checkArguments()
            main(server_ip, server_port)
    </code>
</pre>
